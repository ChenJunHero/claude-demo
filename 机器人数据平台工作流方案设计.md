# 机器人数据平台工作流方案设计文档

## 文档版本
- 版本号：v1.0
- 创建日期：2025-10-10
- 文档状态：初稿

---

## 目录
1. [需求分析](#1-需求分析)
2. [Dify 可行性分析](#2-dify-可行性分析)
3. [推荐方案对比](#3-推荐方案对比)
4. [方案详细说明](#4-方案详细说明)
5. [最终推荐方案：n8n](#5-最终推荐方案n8n)
6. [实施方案](#6-实施方案)
7. [完整示例](#7-完整示例)
8. [总结与建议](#8-总结与建议)

---

## 1. 需求分析

### 1.1 业务背景
- **公司业务**：机器人数据平台
- **数据来源**：采集的文件数据存储在阿里云 OSS
- **核心需求**：可视化的数据处理流程管理

### 1.2 功能需求

#### 核心功能
1. **数据读取**
   - 从阿里云 OSS 读取文件
   - 支持多种文件格式（JSON、CSV、二进制等）

2. **数据处理**
   - 开发者可编写自定义脚本
   - 支持 Python、JavaScript 等语言
   - 数据格式转换和处理

3. **数据输出**
   - 通过 HTTP 节点发送数据
   - 支持多个目标端点
   - 数据传输到指定环节

4. **工作流编排**
   - 可视化拖拽式编辑
   - 节点连接和流程设计
   - 任务调度和执行

5. **平台集成**
   - 内嵌到现有数据平台
   - 与平台无缝集成
   - 统一的用户体验

### 1.3 技术需求

```
数据流程：
阿里云 OSS → 读取节点 → 脚本处理 → 格式转换 → HTTP 发送 → 目标系统

技术要求：
- 可视化编辑器
- REST API 支持
- 可嵌入式架构
- 自定义脚本支持
- 任务调度能力
- 日志监控
```

---

## 2. Dify 可行性分析

### 2.1 Dify 简介

Dify 是一个开源的 LLM 应用开发平台，主要用于构建 AI 应用和智能体。

**核心功能**：
- Chatflow：对话式应用
- Workflow：自动化流程
- 代码节点、IF/ELSE 节点、迭代节点
- HTTP 请求节点

### 2.2 适用性分析

#### ✅ Dify 的优势
- 可视化工作流编辑
- 支持代码节点
- HTTP 请求节点
- 定时和事件触发

#### ❌ Dify 的局限性

1. **定位不匹配**
   - 主要面向 LLM 应用开发（AI Agent、对话机器人）
   - 不是专门的数据处理工作流引擎

2. **数据处理能力有限**
   - 缺少原生的文件系统集成
   - 没有 OSS 读取的原生支持
   - 批量数据处理能力较弱

3. **内嵌集成困难**
   - 内嵌能力有限
   - API 不够完善
   - 难以白标化集成

4. **扩展性问题**
   - 自定义节点开发困难
   - 插件生态不成熟
   - 社区主要关注 AI 场景

### 2.3 结论

**Dify 不适合作为数据平台的工作流引擎**

推荐原因：
- ❌ 核心定位不符（AI 应用 vs 数据处理）
- ❌ 数据处理能力不足
- ❌ 内嵌集成能力有限
- ❌ OSS 集成需要大量定制

---

## 3. 推荐方案对比

### 3.1 可内嵌工作流引擎对比表

| 方案 | 可视化编辑 | 内嵌难度 | 技术栈 | 许可证 | 社区活跃度 | 学习曲线 | 适合场景 |
|------|-----------|---------|--------|--------|-----------|---------|---------|
| **n8n** | ⭐⭐⭐⭐⭐ 拖拽式 | ⭐⭐⭐⭐⭐ 极简单 | Node.js | Fair-code | ⭐⭐⭐⭐⭐ | 低 | 快速内嵌，低代码 |
| **Argo Workflows** | ⭐⭐⭐ YAML+UI | ⭐⭐⭐⭐ 中等 | Go | Apache 2.0 | ⭐⭐⭐⭐⭐ | 中 | Kubernetes 原生 |
| **Windmill** | ⭐⭐⭐⭐ 混合模式 | ⭐⭐⭐⭐ 中等 | Rust/TS | AGPLv3 | ⭐⭐⭐⭐ | 中 | 开发者友好 |
| **Temporal** | ⭐⭐ 纯代码 | ⭐⭐⭐ 复杂 | Go/Python/Java | MIT | ⭐⭐⭐⭐⭐ | 高 | 企业级可靠性 |
| **Prefect** | ⭐⭐⭐ 有限可视化 | ⭐⭐⭐⭐ 中等 | Python | Apache 2.0 | ⭐⭐⭐⭐ | 中 | 数据工程 |
| **Apache Airflow** | ⭐⭐⭐ 监控为主 | ⭐⭐ 困难 | Python | Apache 2.0 | ⭐⭐⭐⭐⭐ | 高 | 大数据处理 |
| **Apache NiFi** | ⭐⭐⭐⭐⭐ 拖拽式 | ⭐⭐ 困难 | Java | Apache 2.0 | ⭐⭐⭐⭐ | 高 | 企业数据流 |

### 3.2 详细评分

#### n8n（总分：95/100）
- 可视化编辑：20/20
- 内嵌集成：20/20
- 开发体验：18/20
- 性能表现：15/20
- 生态丰富度：22/20

#### Argo Workflows（总分：86/100）
- 可视化编辑：12/20
- 内嵌集成：17/20
- 开发体验：17/20
- 性能表现：19/20
- 生态丰富度：21/20

#### Windmill（总分：88/100）
- 可视化编辑：18/20
- 内嵌集成：18/20
- 开发体验：19/20
- 性能表现：18/20
- 生态丰富度：15/20

#### Temporal（总分：85/100）
- 可视化编辑：8/20
- 内嵌集成：15/20
- 开发体验：18/20
- 性能表现：20/20
- 生态丰富度：24/20

#### Prefect（总分：82/100）
- 可视化编辑：12/20
- 内嵌集成：16/20
- 开发体验：18/20
- 性能表现：18/20
- 生态丰富度：18/20

---

## 4. 方案详细说明

### 4.1 方案1：n8n（最推荐 ⭐⭐⭐⭐⭐）

#### 4.1.1 产品介绍

n8n 是一个开源的工作流自动化工具，提供可视化的节点编排界面。

**官网**：https://n8n.io/
**GitHub**：https://github.com/n8n-io/n8n
**Star 数**：45k+

#### 4.1.2 核心优势

**1. 完全可内嵌**
- 提供 Embed License，支持白标集成
- iframe 嵌入编辑器
- REST API 完全可控
- 可以隐藏 n8n 品牌

**2. 可视化编辑**
- 拖拽式节点连接
- 实时测试每个节点
- 可视化数据流
- 直观的调试界面

**3. 丰富的节点库**
- 400+ 内置集成
- HTTP Request 节点
- Code 节点（JavaScript/Python）
- 数据转换节点
- 文件处理节点

**4. 易于扩展**
- 自定义节点开发简单
- 社区活跃，插件丰富
- 可以创建 OSS 节点

**5. 部署简单**
- Docker 一键部署
- 支持自托管
- 资源占用低

#### 4.1.3 集成方式

**方式1：iframe 嵌入编辑器**
```html
<iframe
  src="http://your-n8n-instance/workflow/new"
  width="100%"
  height="800px"
></iframe>
```

**方式2：REST API 调用**
```javascript
// 创建工作流
fetch('http://your-n8n-instance/api/v1/workflows', {
  method: 'POST',
  headers: {
    'X-N8N-API-KEY': 'your-api-key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    name: 'Robot Data Pipeline',
    nodes: [...],
    connections: {...}
  })
})

// 执行工作流
fetch('http://your-n8n-instance/api/v1/workflows/{id}/execute', {
  method: 'POST',
  body: JSON.stringify({ data: {...} })
})
```

**方式3：Webhook 触发**
```bash
curl -X POST \
  http://your-n8n-instance/webhook/your-workflow-id \
  -H 'Content-Type: application/json' \
  -d '{"ossPath": "bucket/data.json"}'
```

#### 4.1.4 技术架构

```
┌─────────────────────────────────────────────┐
│         您的数据平台（前端）                  │
│  ┌─────────────────────────────────────┐   │
│  │  工作流管理页面                      │   │
│  │  ┌─────────────────────────────┐   │   │
│  │  │ n8n 编辑器 (iframe)          │   │   │
│  │  │  [OSS] → [脚本] → [HTTP]     │   │   │
│  │  └─────────────────────────────┘   │   │
│  │  [保存] [执行] [日志]               │   │
│  └─────────────────────────────────────┘   │
└─────────────────────────────────────────────┘
            ↓ REST API
┌─────────────────────────────────────────────┐
│         n8n 后端服务                         │
│  - 工作流引擎                                │
│  - 任务调度器                                │
│  - 日志系统                                  │
└─────────────────────────────────────────────┘
```

#### 4.1.5 优缺点总结

**优点**：
- ✅ 真正的可视化编辑，产品经理也能用
- ✅ 内嵌集成最简单
- ✅ 开源免费（Fair-code 许可）
- ✅ 节点丰富，易扩展
- ✅ 社区活跃，文档完善
- ✅ 部署简单，维护成本低

**缺点**：
- ⚠️ 大规模并发性能一般（可通过集群解决）
- ⚠️ Fair-code 许可，商业使用需注意
- ⚠️ OSS 节点需要自己开发

---

### 4.2 方案2：Argo Workflows（Kubernetes 原生 ⭐⭐⭐⭐）

#### 4.2.1 产品介绍

Argo Workflows 是一个开源的容器原生工作流引擎，用于在 Kubernetes 上编排并行作业。

**官网**：https://argoproj.github.io/workflows/
**GitHub**：https://github.com/argoproj/argo-workflows
**Star 数**：15k+
**CNCF 状态**：毕业项目

#### 4.2.2 核心优势

**1. Kubernetes 原生**
- 完全为 Kubernetes 设计
- 每个工作流步骤在独立的容器中运行
- 天然支持容器化应用
- 与 K8s 生态深度集成

**2. DAG 工作流**
- 支持复杂的有向无环图（DAG）
- 并行执行优化
- 条件分支和循环
- 工作流模板复用

**3. 可视化 UI**
- 内置 Web UI
- 实时查看工作流执行状态
- 日志查看和调试
- 工作流定义可视化

**4. 企业级特性**
- 大规模并发处理
- 资源配额管理
- 多租户支持
- RBAC 权限控制

**5. 丰富的生态**
- Argo CD（GitOps 部署）
- Argo Rollouts（渐进式交付）
- Argo Events（事件驱动）
- 完整的 Argo 生态系统

#### 4.2.3 工作流定义

**YAML 示例**：
```yaml
apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: robot-data-pipeline-
spec:
  entrypoint: main-dag

  # 定义工作流模板
  templates:

  # 主 DAG
  - name: main-dag
    dag:
      tasks:
      # 1. 从 OSS 读取数据
      - name: read-oss
        template: oss-reader
        arguments:
          parameters:
          - name: oss-path
            value: "sensors/{{workflow.creationTimestamp.Y}}-{{workflow.creationTimestamp.m}}-{{workflow.creationTimestamp.d}}.json"

      # 2. 数据转换
      - name: transform-data
        template: data-transformer
        dependencies: [read-oss]
        arguments:
          parameters:
          - name: input-data
            value: "{{tasks.read-oss.outputs.result}}"

      # 3. 发送 HTTP 请求
      - name: send-http
        template: http-sender
        dependencies: [transform-data]
        arguments:
          parameters:
          - name: data
            value: "{{tasks.transform-data.outputs.result}}"

  # OSS 读取模板
  - name: oss-reader
    inputs:
      parameters:
      - name: oss-path
    container:
      image: python:3.9-slim
      command: [python]
      args:
        - -c
        - |
          import oss2
          import json
          import os

          # 从环境变量获取凭证
          access_key_id = os.environ['OSS_ACCESS_KEY_ID']
          access_key_secret = os.environ['OSS_ACCESS_KEY_SECRET']
          bucket_name = os.environ['OSS_BUCKET']
          endpoint = os.environ['OSS_ENDPOINT']

          # 创建 OSS 客户端
          auth = oss2.Auth(access_key_id, access_key_secret)
          bucket = oss2.Bucket(auth, endpoint, bucket_name)

          # 读取文件
          oss_path = "{{inputs.parameters.oss-path}}"
          obj = bucket.get_object(oss_path)
          data = obj.read().decode('utf-8')

          # 输出数据
          print(data)
      env:
      - name: OSS_ACCESS_KEY_ID
        valueFrom:
          secretKeyRef:
            name: oss-credentials
            key: access-key-id
      - name: OSS_ACCESS_KEY_SECRET
        valueFrom:
          secretKeyRef:
            name: oss-credentials
            key: access-key-secret
      - name: OSS_BUCKET
        value: "robot-data-bucket"
      - name: OSS_ENDPOINT
        value: "oss-cn-hangzhou.aliyuncs.com"

  # 数据转换模板
  - name: data-transformer
    inputs:
      parameters:
      - name: input-data
    script:
      image: python:3.9-slim
      command: [python]
      source: |
        import json
        import sys

        # 读取输入数据
        input_data = '''{{inputs.parameters.input-data}}'''
        data = json.loads(input_data)

        # 数据转换逻辑
        transformed = {
            "robot_id": data.get("id"),
            "sensors": data.get("sensors"),
            "timestamp": data.get("timestamp"),
            "processed_at": "{{workflow.creationTimestamp}}"
        }

        # 输出转换后的数据
        print(json.dumps(transformed))

  # HTTP 发送模板
  - name: http-sender
    inputs:
      parameters:
      - name: data
    container:
      image: curlimages/curl:latest
      command: [sh, -c]
      args:
        - |
          curl -X POST https://api.example.com/data \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer {{workflow.parameters.api-token}}" \
            -d '{{inputs.parameters.data}}'
```

#### 4.2.4 集成方式

**1. 通过 Kubernetes API**
```python
from kubernetes import client, config
import yaml

# 加载 Kubernetes 配置
config.load_kube_config()

# 创建 Argo Workflows API 客户端
api = client.CustomObjectsApi()

# 定义工作流
workflow_manifest = {
    "apiVersion": "argoproj.io/v1alpha1",
    "kind": "Workflow",
    "metadata": {
        "generateName": "robot-data-pipeline-"
    },
    "spec": {
        # ... 工作流定义
    }
}

# 提交工作流
api.create_namespaced_custom_object(
    group="argoproj.io",
    version="v1alpha1",
    namespace="default",
    plural="workflows",
    body=workflow_manifest
)
```

**2. 通过 Argo CLI**
```bash
# 提交工作流
argo submit workflow.yaml

# 列出工作流
argo list

# 查看工作流状态
argo get robot-data-pipeline-xxxxx

# 查看日志
argo logs robot-data-pipeline-xxxxx

# 删除工作流
argo delete robot-data-pipeline-xxxxx
```

**3. 通过 Argo Server API**
```typescript
// 使用 REST API
import axios from 'axios';

const argoServerUrl = 'https://argo-server.example.com';
const namespace = 'default';

// 创建工作流
async function submitWorkflow(workflowSpec: any) {
    const response = await axios.post(
        `${argoServerUrl}/api/v1/workflows/${namespace}`,
        {
            workflow: workflowSpec
        },
        {
            headers: {
                'Authorization': `Bearer ${process.env.ARGO_TOKEN}`
            }
        }
    );

    return response.data;
}

// 获取工作流状态
async function getWorkflow(workflowName: string) {
    const response = await axios.get(
        `${argoServerUrl}/api/v1/workflows/${namespace}/${workflowName}`,
        {
            headers: {
                'Authorization': `Bearer ${process.env.ARGO_TOKEN}`
            }
        }
    );

    return response.data;
}
```

**4. 嵌入 Argo UI**
```html
<!-- 在您的平台中嵌入 Argo UI -->
<iframe
    src="https://argo-server.example.com/workflows/default/robot-data-pipeline-xxxxx"
    width="100%"
    height="800px"
    frameborder="0"
></iframe>
```

#### 4.2.5 架构设计

```
┌───────────────────────────────────────────────┐
│       您的数据平台（前端）                     │
│  ┌─────────────────────────────────────┐    │
│  │  工作流管理                          │    │
│  │  - 创建工作流（YAML 编辑器）         │    │
│  │  - 查看工作流列表                    │    │
│  │  - 嵌入 Argo UI (iframe)            │    │
│  └─────────────────────────────────────┘    │
└───────────────────────────────────────────────┘
            ↓ REST API
┌───────────────────────────────────────────────┐
│       您的平台后端                            │
│  - 工作流 YAML 生成                           │
│  - 调用 Kubernetes API                       │
│  - 权限控制                                   │
└───────────────────────────────────────────────┘
            ↓ Kubernetes API
┌───────────────────────────────────────────────┐
│       Kubernetes 集群                         │
│  ┌─────────────────────────────────────┐    │
│  │    Argo Workflows Controller         │    │
│  │  - 监听 Workflow CRD                 │    │
│  │  - 创建 Pod 执行任务                 │    │
│  │  - 管理工作流生命周期                │    │
│  └─────────────────────────────────────┘    │
│  ┌─────────────────────────────────────┐    │
│  │    Argo Server (API + UI)            │    │
│  │  - REST API                          │    │
│  │  - Web UI                            │    │
│  │  - SSO 集成                          │    │
│  └─────────────────────────────────────┘    │
│  ┌─────────────────────────────────────┐    │
│  │    Workflow Pods                     │    │
│  │  - OSS Reader Pod                    │    │
│  │  - Data Transformer Pod              │    │
│  │  - HTTP Sender Pod                   │    │
│  └─────────────────────────────────────┘    │
└───────────────────────────────────────────────┘
```

#### 4.2.6 优缺点总结

**优点**：
- ✅ Kubernetes 原生，容器化友好
- ✅ 高性能并发处理
- ✅ CNCF 毕业项目，生态成熟
- ✅ 支持复杂的 DAG 工作流
- ✅ 内置 UI，可视化监控
- ✅ 与 CI/CD 集成良好
- ✅ 支持大规模任务执行

**缺点**：
- ❌ 需要 Kubernetes 集群（部署成本高）
- ⚠️ YAML 定义，可视化编辑能力有限
- ⚠️ 学习曲线中等（需要了解 K8s）
- ⚠️ 对非容器化场景不友好
- ⚠️ 内嵌集成需要自己开发编辑器

**适用场景**：
- ✅ 已有 Kubernetes 基础设施
- ✅ 需要大规模并行处理
- ✅ 容器化的数据处理流程
- ✅ 需要与 CI/CD 集成
- ✅ 团队熟悉 Kubernetes

---

### 4.3 方案3：Windmill（新兴选择 ⭐⭐⭐⭐⭐）

#### 4.3.1 产品介绍

Windmill 是一个快速的开源工作流引擎和开发者平台。

**官网**：https://www.windmill.dev/
**GitHub**：https://github.com/windmill-labs/windmill
**Star 数**：10k+
**特点**：号称比 Airflow 快 13 倍

#### 4.3.2 核心优势

**1. 极速性能**
- 用 Rust 编写，性能卓越
- 比 Airflow 快 13 倍
- 适合大规模数据处理

**2. 开发者友好**
- 支持 TypeScript、Python、Go、Bash、SQL、Rust
- 代码即工作流
- 内置 IDE
- 版本控制集成

**3. 混合模式**
- 可视化 + 代码结合
- 低代码构建器
- Pro-code 支持

**4. 可嵌入**
- 提供商业许可证
- REST API
- SDK 支持

#### 4.3.3 集成方式

**Python SDK**
```python
from windmill import client

# 连接到 Windmill
wmill = client.Client(token="your-token")

# 创建工作流
wmill.create_flow({
    "summary": "Robot Data Pipeline",
    "value": {
        "modules": [
            {
                "id": "read_oss",
                "type": "script",
                "value": {
                    "language": "python",
                    "content": "# OSS 读取脚本"
                }
            },
            {
                "id": "transform",
                "type": "script",
                "value": {
                    "language": "python",
                    "content": "# 数据转换"
                }
            },
            {
                "id": "http_send",
                "type": "http",
                "value": {
                    "url": "https://api.example.com/data"
                }
            }
        ]
    }
})

# 执行工作流
result = wmill.run_flow("robot-data-pipeline", {"oss_path": "..."})
```

**REST API**
```bash
# 创建脚本
curl -X POST https://windmill.example.com/api/w/workspace/scripts/create \
  -H "Authorization: Bearer $TOKEN" \
  -d '{
    "path": "robot/read_oss",
    "language": "python3",
    "content": "import oss2\n# 读取逻辑"
  }'

# 执行脚本
curl -X POST https://windmill.example.com/api/w/workspace/jobs/run/p/robot/read_oss \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"oss_path": "bucket/data.json"}'
```

#### 4.3.4 优缺点总结

**优点**：
- ✅ 性能极佳，适合大规模处理
- ✅ 开发者友好，多语言支持
- ✅ 现代化架构
- ✅ 可视化 + 代码灵活结合

**缺点**：
- ⚠️ 社区相对较小
- ⚠️ 商业嵌入需要许可证（联系 sales@windmill.dev）
- ⚠️ 学习曲线略高于 n8n

---

### 4.4 方案4：Temporal（企业级 ⭐⭐⭐⭐）

#### 4.4.1 产品介绍

Temporal 是一个开源的持久化执行平台，用于构建可靠的分布式系统。

**官网**：https://temporal.io/
**GitHub**：https://github.com/temporalio/temporal
**使用者**：Uber、Netflix、Stripe

#### 4.4.2 核心优势

**1. 持久化执行**
- 任务永不丢失
- 自动重试机制
- 状态自动保存

**2. 企业级可靠性**
- 经过大规模验证
- 分布式架构
- 高可用性

**3. SDK 集成**
- Python、Go、Java、TypeScript
- 嵌入到应用代码中
- 类型安全

#### 4.4.3 集成方式

**Python SDK**
```python
from temporalio import workflow, activity
from temporalio.client import Client
from temporalio.worker import Worker

# 定义 Activity
@activity.defn
async def read_oss(oss_path: str) -> dict:
    import oss2
    # 读取 OSS 文件
    return {"data": "..."}

@activity.defn
async def transform_data(data: dict) -> dict:
    # 数据转换
    return {"transformed": "..."}

@activity.defn
async def send_http(data: dict) -> dict:
    import httpx
    # 发送 HTTP
    return {"status": "sent"}

# 定义 Workflow
@workflow.defn
class RobotDataWorkflow:
    @workflow.run
    async def run(self, oss_path: str) -> dict:
        # 1. 读取 OSS
        data = await workflow.execute_activity(
            read_oss,
            oss_path,
            start_to_close_timeout=timedelta(minutes=5)
        )

        # 2. 转换数据
        transformed = await workflow.execute_activity(
            transform_data,
            data,
            start_to_close_timeout=timedelta(minutes=2)
        )

        # 3. 发送 HTTP
        result = await workflow.execute_activity(
            send_http,
            transformed,
            start_to_close_timeout=timedelta(minutes=1)
        )

        return result

# 在您的平台中集成
async def main():
    # 连接 Temporal Server
    client = await Client.connect("temporal-server:7233")

    # 启动 Worker（在后台服务中）
    worker = Worker(
        client,
        task_queue="robot-data",
        workflows=[RobotDataWorkflow],
        activities=[read_oss, transform_data, send_http]
    )
    await worker.run()

    # 在您的 API 中执行工作流
    result = await client.execute_workflow(
        RobotDataWorkflow.run,
        "oss://bucket/data.json",
        id="robot-data-" + str(uuid.uuid4()),
        task_queue="robot-data"
    )

    return result
```

#### 4.4.4 优缺点总结

**优点**：
- ✅ 企业级可靠性
- ✅ 永不丢失的任务执行
- ✅ 成熟的分布式架构
- ✅ 大公司验证

**缺点**：
- ❌ 无可视化编辑器（纯代码）
- ⚠️ 学习曲线陡峭
- ⚠️ 部署和维护复杂
- ⚠️ 对于简单场景过度设计

---

### 4.5 方案5：Prefect（Python 友好 ⭐⭐⭐⭐）

#### 4.5.1 产品介绍

Prefect 是一个现代化的工作流编排平台，Python-first 设计。

**官网**：https://www.prefect.io/
**GitHub**：https://github.com/PrefectHQ/prefect

#### 4.5.2 核心优势

**1. Python-first**
- 纯 Python 编写工作流
- Pythonic API 设计
- 易于本地测试

**2. 优雅的 UI**
- 现代化的 Web 界面
- 实时监控
- 日志可视化

**3. 动态工作流**
- 工作流可以动态生成
- 参数化支持
- 灵活的调度

#### 4.5.3 集成方式

```python
from prefect import flow, task
from prefect.deployments import Deployment
from prefect.server.schemas.schedules import CronSchedule

@task
def read_oss(oss_path: str):
    """读取 OSS 文件"""
    import oss2
    auth = oss2.Auth('access_key_id', 'access_key_secret')
    bucket = oss2.Bucket(auth, 'endpoint', 'bucket_name')

    obj = bucket.get_object(oss_path)
    return obj.read()

@task
def transform_data(data: bytes):
    """转换数据"""
    import json
    raw_data = json.loads(data)

    # 您的转换逻辑
    transformed = {
        "robot_id": raw_data.get("id"),
        "sensors": raw_data.get("sensors"),
        "timestamp": raw_data.get("ts")
    }

    return transformed

@task
def send_http(data: dict):
    """发送 HTTP 请求"""
    import httpx

    response = httpx.post(
        "https://api.example.com/data",
        json=data,
        headers={"Content-Type": "application/json"}
    )

    return response.json()

@flow(name="robot-data-pipeline")
def robot_data_pipeline(oss_path: str):
    """机器人数据处理流程"""
    # 1. 读取 OSS
    raw_data = read_oss(oss_path)

    # 2. 转换数据
    transformed_data = transform_data(raw_data)

    # 3. 发送 HTTP
    result = send_http(transformed_data)

    return result

# 部署工作流
if __name__ == "__main__":
    deployment = Deployment.build_from_flow(
        flow=robot_data_pipeline,
        name="robot-data-pipeline-prod",
        schedule=CronSchedule(cron="0 * * * *")  # 每小时执行
    )
    deployment.apply()
```

**在您的平台中调用**：
```python
from prefect.client import get_client
from prefect.deployments import run_deployment

async def trigger_workflow(oss_path: str):
    """在您的平台 API 中触发工作流"""
    async with get_client() as client:
        flow_run = await run_deployment(
            name="robot-data-pipeline/robot-data-pipeline-prod",
            parameters={"oss_path": oss_path}
        )
        return flow_run.id
```

#### 4.5.4 优缺点总结

**优点**：
- ✅ Python 生态，数据团队友好
- ✅ 现代化 UI
- ✅ 易于本地开发和测试
- ✅ 动态工作流支持

**缺点**：
- ⚠️ 可视化编辑有限（主要是代码）
- ⚠️ 内嵌集成相对复杂
- ⚠️ 社区规模不如 Airflow

---

## 5. 最终推荐方案：n8n

### 5.1 为什么选择 n8n？

基于您的需求分析，n8n 是最佳选择，原因如下：

#### 1. 完美匹配需求
- ✅ 真正的可视化编辑器
- ✅ 支持自定义脚本（Python/JavaScript）
- ✅ 内置 HTTP 节点
- ✅ 可以开发 OSS 自定义节点

#### 2. 内嵌集成最简单
- ✅ iframe 一行代码嵌入
- ✅ REST API 完整
- ✅ 可以白标化
- ✅ 部署简单

#### 3. 用户友好
- ✅ 拖拽式操作，学习成本低
- ✅ 产品经理、数据分析师也能用
- ✅ 实时测试和调试
- ✅ 直观的数据流展示

#### 4. 开发者友好
- ✅ 自定义节点开发简单
- ✅ 代码节点支持 Python/JS
- ✅ 丰富的文档和示例
- ✅ 活跃的社区

#### 5. 成本效益高
- ✅ 开源免费（Fair-code）
- ✅ 部署维护成本低
- ✅ 资源占用小
- ✅ 可以自托管

### 5.2 n8n 架构设计

```
┌───────────────────────────────────────────────────────┐
│            您的机器人数据平台（前端）                   │
│                                                       │
│  ┌─────────────────────────────────────────────┐     │
│  │        工作流管理页面                        │     │
│  │                                             │     │
│  │  ┌───────────────────────────────────┐     │     │
│  │  │     工作流列表                     │     │     │
│  │  │  - Robot Sensor Data Pipeline    │     │     │
│  │  │  - Video Processing Workflow     │     │     │
│  │  │  - Log Analysis Pipeline         │     │     │
│  │  │  [+ 新建工作流]                   │     │     │
│  │  └───────────────────────────────────┘     │     │
│  │                                             │     │
│  │  ┌───────────────────────────────────┐     │     │
│  │  │   n8n 可视化编辑器 (iframe)        │     │     │
│  │  │                                   │     │     │
│  │  │  ┌──────┐   ┌──────┐   ┌──────┐ │     │     │
│  │  │  │ OSS  │→→→│Script│→→→│ HTTP │ │     │     │
│  │  │  │Reader│   │ Node │   │ Send │ │     │     │
│  │  │  └──────┘   └──────┘   └──────┘ │     │     │
│  │  │                                   │     │     │
│  │  └───────────────────────────────────┘     │     │
│  │                                             │     │
│  │  [💾 保存]  [▶️ 执行]  [📊 查看日志]       │     │
│  └─────────────────────────────────────────────┘     │
│                                                       │
└───────────────────────────────────────────────────────┘
                        ↓ REST API
┌───────────────────────────────────────────────────────┐
│              您的平台后端 (Node.js/Python)             │
│                                                       │
│  - 工作流管理 API                                      │
│  - 用户权限控制                                        │
│  - 日志聚合                                           │
│  - 数据统计                                           │
│                                                       │
└───────────────────────────────────────────────────────┘
                        ↓ 调用
┌───────────────────────────────────────────────────────┐
│                 n8n 后端服务                           │
│                                                       │
│  ┌─────────────────────────────────────────────┐     │
│  │         工作流引擎                           │     │
│  │  - 工作流执行                                │     │
│  │  - 节点调度                                  │     │
│  │  - 状态管理                                  │     │
│  └─────────────────────────────────────────────┘     │
│                                                       │
│  ┌─────────────────────────────────────────────┐     │
│  │         任务队列 (Redis)                     │     │
│  │  - 任务调度                                  │     │
│  │  - 并发控制                                  │     │
│  └─────────────────────────────────────────────┘     │
│                                                       │
│  ┌─────────────────────────────────────────────┐     │
│  │         数据存储 (PostgreSQL)                │     │
│  │  - 工作流定义                                │     │
│  │  - 执行历史                                  │     │
│  │  - 日志记录                                  │     │
│  └─────────────────────────────────────────────┘     │
│                                                       │
└───────────────────────────────────────────────────────┘
                        ↓
┌───────────────────────────────────────────────────────┐
│              外部系统                                  │
│                                                       │
│  - 阿里云 OSS                                         │
│  - 目标 API 端点                                      │
│  - 其他数据源                                         │
│                                                       │
└───────────────────────────────────────────────────────┘
```

### 5.3 数据流程图

```
┌─────────────────────────────────────────────┐
│         机器人数据处理完整流程                │
└─────────────────────────────────────────────┘

1. 触发工作流
   ├─ 定时触发（Cron）
   ├─ API 调用触发
   ├─ Webhook 触发
   └─ 手动触发
        ↓
2. OSS Reader 节点
   ├─ 连接阿里云 OSS
   ├─ 根据路径读取文件
   ├─ 支持多种格式（JSON/CSV/二进制）
   └─ 输出：原始数据
        ↓
3. Data Validation 节点（可选）
   ├─ 验证数据格式
   ├─ 检查必填字段
   └─ 输出：验证结果
        ↓
4. Script 节点（Python/JavaScript）
   ├─ 自定义数据转换逻辑
   ├─ 格式转换
   ├─ 数据清洗
   ├─ 计算派生字段
   └─ 输出：转换后的数据
        ↓
5. IF/ELSE 节点（可选）
   ├─ 根据条件分支
   ├─ 错误处理
   └─ 不同数据类型不同处理
        ↓
6. HTTP Request 节点
   ├─ POST 到目标 API
   ├─ 设置请求头
   ├─ 请求体格式化
   └─ 输出：API 响应
        ↓
7. Log 节点
   ├─ 记录执行日志
   ├─ 错误追踪
   └─ 性能监控
        ↓
8. 完成
   └─ 返回执行结果
```

---

## 6. 实施方案

### 6.1 环境准备

#### 6.1.1 系统要求
- **服务器**：2 核 CPU、4GB 内存（最低配置）
- **存储**：20GB（用于日志和数据库）
- **网络**：需要访问阿里云 OSS 和目标 API
- **域名**：可选，建议配置 HTTPS

#### 6.1.2 依赖服务
- Docker & Docker Compose
- PostgreSQL（或使用 SQLite）
- Redis（可选，用于队列）

### 6.2 部署 n8n

#### 6.2.1 使用 Docker Compose 部署

创建 `docker-compose.yml`：

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:14
    restart: always
    environment:
      POSTGRES_DB: n8n
      POSTGRES_USER: n8n
      POSTGRES_PASSWORD: n8n_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - n8n-network

  redis:
    image: redis:7
    restart: always
    networks:
      - n8n-network

  n8n:
    image: n8nio/n8n:latest
    restart: always
    ports:
      - "5678:5678"
    environment:
      # 数据库配置
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_DATABASE=n8n
      - DB_POSTGRESDB_USER=n8n
      - DB_POSTGRESDB_PASSWORD=n8n_password

      # 执行模式
      - EXECUTIONS_MODE=queue
      - QUEUE_BULL_REDIS_HOST=redis

      # 基础配置
      - N8N_HOST=your-domain.com
      - N8N_PORT=5678
      - N8N_PROTOCOL=https
      - WEBHOOK_URL=https://your-domain.com/

      # 安全配置
      - N8N_BASIC_AUTH_ACTIVE=true
      - N8N_BASIC_AUTH_USER=admin
      - N8N_BASIC_AUTH_PASSWORD=your_secure_password

      # API 配置
      - N8N_API_KEY_AUTH_ENABLED=true

      # 自定义节点路径
      - N8N_CUSTOM_EXTENSIONS=/home/node/.n8n/custom

      # 时区
      - GENERIC_TIMEZONE=Asia/Shanghai

    volumes:
      - n8n_data:/home/node/.n8n
      - ./custom-nodes:/home/node/.n8n/custom
    depends_on:
      - postgres
      - redis
    networks:
      - n8n-network

volumes:
  postgres_data:
  n8n_data:

networks:
  n8n-network:
    driver: bridge
```

#### 6.2.2 启动服务

```bash
# 启动
docker-compose up -d

# 查看日志
docker-compose logs -f n8n

# 停止
docker-compose down

# 重启
docker-compose restart n8n
```

#### 6.2.3 配置 Nginx 反向代理（可选）

```nginx
server {
    listen 80;
    server_name your-n8n-domain.com;

    # 重定向到 HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name your-n8n-domain.com;

    # SSL 证书配置
    ssl_certificate /etc/ssl/certs/your-cert.pem;
    ssl_certificate_key /etc/ssl/private/your-key.pem;

    location / {
        proxy_pass http://localhost:5678;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
}
```

### 6.3 开发 OSS 自定义节点

#### 6.3.1 创建节点目录结构

```
custom-nodes/
└── nodes/
    └── AliOss/
        ├── AliOss.node.ts
        ├── AliOss.node.json
        └── ali-oss-icon.svg
```

#### 6.3.2 节点代码实现

`AliOss.node.ts`：

```typescript
import {
    IExecuteFunctions,
    INodeExecutionData,
    INodeType,
    INodeTypeDescription,
} from 'n8n-workflow';

import OSS from 'ali-oss';

export class AliOss implements INodeType {
    description: INodeTypeDescription = {
        displayName: 'Ali OSS',
        name: 'aliOss',
        icon: 'file:ali-oss-icon.svg',
        group: ['transform'],
        version: 1,
        description: '阿里云 OSS 文件操作',
        defaults: {
            name: 'Ali OSS',
        },
        inputs: ['main'],
        outputs: ['main'],
        credentials: [
            {
                name: 'aliOssApi',
                required: true,
            },
        ],
        properties: [
            {
                displayName: 'Operation',
                name: 'operation',
                type: 'options',
                options: [
                    {
                        name: 'Get',
                        value: 'get',
                        description: '读取文件',
                    },
                    {
                        name: 'Put',
                        value: 'put',
                        description: '上传文件',
                    },
                    {
                        name: 'List',
                        value: 'list',
                        description: '列出文件',
                    },
                ],
                default: 'get',
            },
            {
                displayName: 'Bucket',
                name: 'bucket',
                type: 'string',
                default: '',
                required: true,
                description: 'OSS Bucket 名称',
            },
            {
                displayName: 'Object Path',
                name: 'objectPath',
                type: 'string',
                default: '',
                displayOptions: {
                    show: {
                        operation: ['get', 'put'],
                    },
                },
                description: '文件路径（例如：data/robot-sensor.json）',
            },
            {
                displayName: 'Prefix',
                name: 'prefix',
                type: 'string',
                default: '',
                displayOptions: {
                    show: {
                        operation: ['list'],
                    },
                },
                description: '文件前缀（用于过滤）',
            },
            {
                displayName: 'Output Format',
                name: 'outputFormat',
                type: 'options',
                options: [
                    {
                        name: 'JSON',
                        value: 'json',
                    },
                    {
                        name: 'Text',
                        value: 'text',
                    },
                    {
                        name: 'Binary',
                        value: 'binary',
                    },
                ],
                default: 'json',
                displayOptions: {
                    show: {
                        operation: ['get'],
                    },
                },
            },
        ],
    };

    async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
        const items = this.getInputData();
        const returnData: INodeExecutionData[] = [];

        // 获取凭证
        const credentials = await this.getCredentials('aliOssApi');

        // 创建 OSS 客户端
        const client = new OSS({
            accessKeyId: credentials.accessKeyId as string,
            accessKeySecret: credentials.accessKeySecret as string,
            region: credentials.region as string,
            bucket: this.getNodeParameter('bucket', 0) as string,
        });

        const operation = this.getNodeParameter('operation', 0) as string;

        for (let i = 0; i < items.length; i++) {
            try {
                if (operation === 'get') {
                    // 读取文件
                    const objectPath = this.getNodeParameter('objectPath', i) as string;
                    const outputFormat = this.getNodeParameter('outputFormat', i) as string;

                    const result = await client.get(objectPath);

                    let data;
                    if (outputFormat === 'json') {
                        data = JSON.parse(result.content.toString());
                    } else if (outputFormat === 'text') {
                        data = result.content.toString();
                    } else {
                        data = result.content;
                    }

                    returnData.push({
                        json: {
                            objectPath,
                            size: result.res.size,
                            lastModified: result.res.headers['last-modified'],
                            data,
                        },
                    });

                } else if (operation === 'put') {
                    // 上传文件
                    const objectPath = this.getNodeParameter('objectPath', i) as string;
                    const content = items[i].json.content || items[i].binary;

                    const result = await client.put(objectPath, Buffer.from(content));

                    returnData.push({
                        json: {
                            objectPath,
                            url: result.url,
                            etag: result.etag,
                        },
                    });

                } else if (operation === 'list') {
                    // 列出文件
                    const prefix = this.getNodeParameter('prefix', i) as string;

                    const result = await client.list({
                        prefix,
                        'max-keys': 100,
                    });

                    returnData.push({
                        json: {
                            objects: result.objects,
                            prefixes: result.prefixes,
                        },
                    });
                }
            } catch (error) {
                if (this.continueOnFail()) {
                    returnData.push({
                        json: {
                            error: error.message,
                        },
                    });
                    continue;
                }
                throw error;
            }
        }

        return [returnData];
    }
}
```

#### 6.3.3 凭证配置

`credentials/AliOssApi.credentials.ts`：

```typescript
import {
    ICredentialType,
    INodeProperties,
} from 'n8n-workflow';

export class AliOssApi implements ICredentialType {
    name = 'aliOssApi';
    displayName = 'Ali OSS API';
    documentationUrl = 'https://help.aliyun.com/document_detail/32027.html';
    properties: INodeProperties[] = [
        {
            displayName: 'Access Key ID',
            name: 'accessKeyId',
            type: 'string',
            default: '',
            required: true,
        },
        {
            displayName: 'Access Key Secret',
            name: 'accessKeySecret',
            type: 'string',
            typeOptions: {
                password: true,
            },
            default: '',
            required: true,
        },
        {
            displayName: 'Region',
            name: 'region',
            type: 'string',
            default: 'oss-cn-hangzhou',
            description: 'OSS 区域（例如：oss-cn-hangzhou）',
        },
    ];
}
```

#### 6.3.4 安装依赖

在 custom-nodes 目录下创建 `package.json`：

```json
{
  "name": "n8n-nodes-ali-oss",
  "version": "1.0.0",
  "description": "n8n nodes for Aliyun OSS",
  "main": "index.js",
  "n8n": {
    "nodes": [
      "nodes/AliOss/AliOss.node.js"
    ],
    "credentials": [
      "credentials/AliOssApi.credentials.js"
    ]
  },
  "dependencies": {
    "ali-oss": "^6.17.1"
  }
}
```

安装：
```bash
cd custom-nodes
npm install
npm run build
```

### 6.4 前端集成

#### 6.4.1 React 组件示例

```typescript
// WorkflowEditor.tsx
import React, { useEffect, useState } from 'react';
import axios from 'axios';

interface WorkflowEditorProps {
    workflowId?: string;
    onSave?: (workflowId: string) => void;
}

const WorkflowEditor: React.FC<WorkflowEditorProps> = ({ workflowId, onSave }) => {
    const [iframeUrl, setIframeUrl] = useState('');
    const [loading, setLoading] = useState(false);

    useEffect(() => {
        if (workflowId) {
            // 编辑现有工作流
            setIframeUrl(`${process.env.REACT_APP_N8N_URL}/workflow/${workflowId}`);
        } else {
            // 创建新工作流
            setIframeUrl(`${process.env.REACT_APP_N8N_URL}/workflow/new`);
        }
    }, [workflowId]);

    // 监听 iframe 消息
    useEffect(() => {
        const handleMessage = (event: MessageEvent) => {
            if (event.origin !== process.env.REACT_APP_N8N_URL) return;

            if (event.data.type === 'workflow-saved') {
                const savedWorkflowId = event.data.workflowId;
                if (onSave) {
                    onSave(savedWorkflowId);
                }
            }
        };

        window.addEventListener('message', handleMessage);
        return () => window.removeEventListener('message', handleMessage);
    }, [onSave]);

    return (
        <div className="workflow-editor-container">
            <div className="editor-toolbar">
                <h2>{workflowId ? '编辑工作流' : '创建工作流'}</h2>
                <button onClick={() => window.history.back()}>返回</button>
            </div>

            {loading && <div className="loading">加载中...</div>}

            <iframe
                src={iframeUrl}
                width="100%"
                height="800px"
                frameBorder="0"
                style={{ border: 'none' }}
                onLoad={() => setLoading(false)}
            />
        </div>
    );
};

export default WorkflowEditor;
```

#### 6.4.2 工作流列表组件

```typescript
// WorkflowList.tsx
import React, { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { workflowService } from '../services/workflow';

interface Workflow {
    id: string;
    name: string;
    active: boolean;
    createdAt: string;
    updatedAt: string;
}

const WorkflowList: React.FC = () => {
    const [workflows, setWorkflows] = useState<Workflow[]>([]);
    const [loading, setLoading] = useState(true);
    const navigate = useNavigate();

    useEffect(() => {
        loadWorkflows();
    }, []);

    const loadWorkflows = async () => {
        try {
            const data = await workflowService.getAll();
            setWorkflows(data);
        } catch (error) {
            console.error('加载工作流失败:', error);
        } finally {
            setLoading(false);
        }
    };

    const handleExecute = async (workflowId: string) => {
        try {
            await workflowService.execute(workflowId);
            alert('工作流已触发执行');
        } catch (error) {
            alert('执行失败');
        }
    };

    const handleDelete = async (workflowId: string) => {
        if (!confirm('确定要删除这个工作流吗？')) return;

        try {
            await workflowService.delete(workflowId);
            loadWorkflows();
        } catch (error) {
            alert('删除失败');
        }
    };

    if (loading) return <div>加载中...</div>;

    return (
        <div className="workflow-list">
            <div className="list-header">
                <h2>工作流管理</h2>
                <button onClick={() => navigate('/workflows/new')}>
                    + 创建工作流
                </button>
            </div>

            <table className="workflow-table">
                <thead>
                    <tr>
                        <th>名称</th>
                        <th>状态</th>
                        <th>更新时间</th>
                        <th>操作</th>
                    </tr>
                </thead>
                <tbody>
                    {workflows.map(workflow => (
                        <tr key={workflow.id}>
                            <td>{workflow.name}</td>
                            <td>
                                <span className={workflow.active ? 'status-active' : 'status-inactive'}>
                                    {workflow.active ? '激活' : '未激活'}
                                </span>
                            </td>
                            <td>{new Date(workflow.updatedAt).toLocaleString()}</td>
                            <td>
                                <button onClick={() => navigate(`/workflows/${workflow.id}`)}>
                                    编辑
                                </button>
                                <button onClick={() => handleExecute(workflow.id)}>
                                    执行
                                </button>
                                <button onClick={() => navigate(`/workflows/${workflow.id}/logs`)}>
                                    日志
                                </button>
                                <button onClick={() => handleDelete(workflow.id)}>
                                    删除
                                </button>
                            </td>
                        </tr>
                    ))}
                </tbody>
            </table>
        </div>
    );
};

export default WorkflowList;
```

### 6.5 后端 API 服务

#### 6.5.1 Node.js 服务示例

```typescript
// src/services/n8n.service.ts
import axios, { AxiosInstance } from 'axios';

export class N8nService {
    private client: AxiosInstance;

    constructor() {
        this.client = axios.create({
            baseURL: process.env.N8N_API_URL || 'http://localhost:5678/api/v1',
            headers: {
                'X-N8N-API-KEY': process.env.N8N_API_KEY,
                'Content-Type': 'application/json',
            },
        });
    }

    // 获取所有工作流
    async getAllWorkflows() {
        const response = await this.client.get('/workflows');
        return response.data.data;
    }

    // 获取单个工作流
    async getWorkflow(workflowId: string) {
        const response = await this.client.get(`/workflows/${workflowId}`);
        return response.data;
    }

    // 创建工作流
    async createWorkflow(workflow: any) {
        const response = await this.client.post('/workflows', workflow);
        return response.data;
    }

    // 更新工作流
    async updateWorkflow(workflowId: string, workflow: any) {
        const response = await this.client.patch(`/workflows/${workflowId}`, workflow);
        return response.data;
    }

    // 删除工作流
    async deleteWorkflow(workflowId: string) {
        await this.client.delete(`/workflows/${workflowId}`);
    }

    // 执行工作流
    async executeWorkflow(workflowId: string, data?: any) {
        const response = await this.client.post(`/workflows/${workflowId}/execute`, {
            data,
        });
        return response.data;
    }

    // 获取执行历史
    async getExecutions(workflowId: string, limit = 20) {
        const response = await this.client.get('/executions', {
            params: {
                workflowId,
                limit,
            },
        });
        return response.data.data;
    }

    // 获取单个执行详情
    async getExecution(executionId: string) {
        const response = await this.client.get(`/executions/${executionId}`);
        return response.data;
    }

    // 激活/停用工作流
    async toggleWorkflowActive(workflowId: string, active: boolean) {
        const response = await this.client.patch(`/workflows/${workflowId}`, {
            active,
        });
        return response.data;
    }
}

export const n8nService = new N8nService();
```

#### 6.5.2 Express API 路由

```typescript
// src/routes/workflow.routes.ts
import { Router } from 'express';
import { n8nService } from '../services/n8n.service';
import { authMiddleware } from '../middleware/auth';

const router = Router();

// 应用认证中间件
router.use(authMiddleware);

// 获取所有工作流
router.get('/workflows', async (req, res) => {
    try {
        const workflows = await n8nService.getAllWorkflows();
        res.json({
            success: true,
            data: workflows,
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message,
        });
    }
});

// 获取单个工作流
router.get('/workflows/:id', async (req, res) => {
    try {
        const workflow = await n8nService.getWorkflow(req.params.id);
        res.json({
            success: true,
            data: workflow,
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message,
        });
    }
});

// 创建工作流
router.post('/workflows', async (req, res) => {
    try {
        const workflow = await n8nService.createWorkflow(req.body);
        res.json({
            success: true,
            data: workflow,
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message,
        });
    }
});

// 更新工作流
router.put('/workflows/:id', async (req, res) => {
    try {
        const workflow = await n8nService.updateWorkflow(req.params.id, req.body);
        res.json({
            success: true,
            data: workflow,
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message,
        });
    }
});

// 删除工作流
router.delete('/workflows/:id', async (req, res) => {
    try {
        await n8nService.deleteWorkflow(req.params.id);
        res.json({
            success: true,
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message,
        });
    }
});

// 执行工作流
router.post('/workflows/:id/execute', async (req, res) => {
    try {
        const result = await n8nService.executeWorkflow(req.params.id, req.body);
        res.json({
            success: true,
            data: result,
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message,
        });
    }
});

// 获取执行历史
router.get('/workflows/:id/executions', async (req, res) => {
    try {
        const limit = parseInt(req.query.limit as string) || 20;
        const executions = await n8nService.getExecutions(req.params.id, limit);
        res.json({
            success: true,
            data: executions,
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message,
        });
    }
});

// 激活/停用工作流
router.patch('/workflows/:id/active', async (req, res) => {
    try {
        const { active } = req.body;
        const workflow = await n8nService.toggleWorkflowActive(req.params.id, active);
        res.json({
            success: true,
            data: workflow,
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message,
        });
    }
});

export default router;
```

---

## 7. 完整示例

### 7.1 示例工作流：机器人传感器数据处理

#### 7.1.1 需求描述
- 每小时从 OSS 读取机器人传感器数据
- 数据格式转换和清洗
- 计算统计指标
- 发送到数据分析平台

#### 7.1.2 工作流定义（JSON）

```json
{
  "name": "Robot Sensor Data Pipeline",
  "nodes": [
    {
      "id": "trigger",
      "type": "n8n-nodes-base.cron",
      "parameters": {
        "triggerTimes": {
          "item": [
            {
              "mode": "everyHour"
            }
          ]
        }
      },
      "position": [250, 300],
      "name": "Hourly Trigger"
    },
    {
      "id": "oss-reader",
      "type": "n8n-nodes-custom.aliOss",
      "parameters": {
        "operation": "get",
        "bucket": "robot-data-bucket",
        "objectPath": "sensors/{{$now.format('YYYY-MM-DD-HH')}}.json",
        "outputFormat": "json"
      },
      "position": [450, 300],
      "name": "Read Sensor Data"
    },
    {
      "id": "validate",
      "type": "n8n-nodes-base.code",
      "parameters": {
        "language": "javascript",
        "code": "// 验证数据格式\nconst data = items[0].json.data;\n\nif (!Array.isArray(data)) {\n  throw new Error('Invalid data format');\n}\n\n// 过滤无效数据\nconst validData = data.filter(item => {\n  return item.robot_id && \n         item.timestamp && \n         item.sensors &&\n         typeof item.sensors.temperature === 'number' &&\n         typeof item.sensors.battery === 'number';\n});\n\nreturn [{ json: { data: validData } }];"
      },
      "position": [650, 300],
      "name": "Validate Data"
    },
    {
      "id": "transform",
      "type": "n8n-nodes-base.code",
      "parameters": {
        "language": "python",
        "code": "# 数据转换和计算\nimport json\nfrom datetime import datetime\nimport statistics\n\ndata = items[0]['json']['data']\n\n# 按机器人分组\nrobot_stats = {}\n\nfor record in data:\n    robot_id = record['robot_id']\n    \n    if robot_id not in robot_stats:\n        robot_stats[robot_id] = {\n            'robot_id': robot_id,\n            'temperatures': [],\n            'batteries': [],\n            'record_count': 0\n        }\n    \n    robot_stats[robot_id]['temperatures'].append(record['sensors']['temperature'])\n    robot_stats[robot_id]['batteries'].append(record['sensors']['battery'])\n    robot_stats[robot_id]['record_count'] += 1\n\n# 计算统计指标\nresults = []\nfor robot_id, stats in robot_stats.items():\n    results.append({\n        'robot_id': robot_id,\n        'timestamp': datetime.now().isoformat(),\n        'stats': {\n            'avg_temperature': statistics.mean(stats['temperatures']),\n            'max_temperature': max(stats['temperatures']),\n            'min_temperature': min(stats['temperatures']),\n            'avg_battery': statistics.mean(stats['batteries']),\n            'min_battery': min(stats['batteries']),\n            'record_count': stats['record_count']\n        }\n    })\n\nreturn [{'json': {'results': results}}]"
      },
      "position": [850, 300],
      "name": "Transform & Calculate"
    },
    {
      "id": "alert-check",
      "type": "n8n-nodes-base.if",
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.stats.min_battery}}",
              "operation": "smaller",
              "value2": 20
            }
          ]
        }
      },
      "position": [1050, 300],
      "name": "Low Battery Alert?"
    },
    {
      "id": "send-alert",
      "type": "n8n-nodes-base.httpRequest",
      "parameters": {
        "method": "POST",
        "url": "https://api.example.com/alerts",
        "jsonParameters": true,
        "options": {},
        "bodyParametersJson": "={\n  \"type\": \"low_battery\",\n  \"robot_id\": \"{{$json.robot_id}}\",\n  \"battery\": {{$json.stats.min_battery}},\n  \"timestamp\": \"{{$json.timestamp}}\"\n}"
      },
      "position": [1250, 200],
      "name": "Send Alert"
    },
    {
      "id": "send-data",
      "type": "n8n-nodes-base.httpRequest",
      "parameters": {
        "method": "POST",
        "url": "https://api.example.com/analytics/robot-stats",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "jsonParameters": true,
        "options": {},
        "bodyParametersJson": "={{$json}}"
      },
      "position": [1250, 400],
      "name": "Send to Analytics"
    },
    {
      "id": "log",
      "type": "n8n-nodes-base.code",
      "parameters": {
        "language": "javascript",
        "code": "console.log('Pipeline completed:', {\n  timestamp: new Date().toISOString(),\n  recordsProcessed: items.length\n});\n\nreturn items;"
      },
      "position": [1450, 300],
      "name": "Log Result"
    }
  ],
  "connections": {
    "trigger": {
      "main": [[{"node": "oss-reader", "type": "main", "index": 0}]]
    },
    "oss-reader": {
      "main": [[{"node": "validate", "type": "main", "index": 0}]]
    },
    "validate": {
      "main": [[{"node": "transform", "type": "main", "index": 0}]]
    },
    "transform": {
      "main": [[{"node": "alert-check", "type": "main", "index": 0}]]
    },
    "alert-check": {
      "main": [
        [{"node": "send-alert", "type": "main", "index": 0}],
        [{"node": "send-data", "type": "main", "index": 0}]
      ]
    },
    "send-alert": {
      "main": [[{"node": "send-data", "type": "main", "index": 0}]]
    },
    "send-data": {
      "main": [[{"node": "log", "type": "main", "index": 0}]]
    }
  },
  "active": true,
  "settings": {
    "timezone": "Asia/Shanghai"
  }
}
```

### 7.2 使用 API 创建工作流

```typescript
// 在您的平台后端创建工作流
import { n8nService } from './services/n8n.service';

async function createRobotSensorPipeline() {
    const workflow = {
        name: 'Robot Sensor Data Pipeline',
        nodes: [
            // ... 节点定义（如上）
        ],
        connections: {
            // ... 连接定义（如上）
        },
        active: true,
    };

    try {
        const created = await n8nService.createWorkflow(workflow);
        console.log('工作流创建成功:', created.id);
        return created;
    } catch (error) {
        console.error('创建失败:', error);
        throw error;
    }
}

// 执行工作流
async function triggerPipeline(ossPath: string) {
    const workflowId = 'your-workflow-id';

    try {
        const result = await n8nService.executeWorkflow(workflowId, {
            ossPath,
        });

        console.log('执行成功:', result);
        return result;
    } catch (error) {
        console.error('执行失败:', error);
        throw error;
    }
}
```

---

## 8. 总结与建议

### 8.1 方案总结

基于机器人数据平台的需求，我们推荐使用 **n8n** 作为工作流引擎：

#### 核心优势
1. ✅ **可视化编辑**：真正的拖拽式操作，降低使用门槛
2. ✅ **易于集成**：iframe 嵌入 + REST API，集成简单
3. ✅ **灵活扩展**：自定义节点开发容易，可创建 OSS 节点
4. ✅ **成本低**：开源免费，部署维护简单
5. ✅ **社区活跃**：400+ 节点，文档完善

#### 实施路径
1. **Phase 1**：部署 n8n 并开发 OSS 自定义节点
2. **Phase 2**：前端集成，实现可视化编辑器嵌入
3. **Phase 3**：后端 API 封装，统一管理工作流
4. **Phase 4**：创建常用工作流模板，方便用户使用

### 8.2 备选方案

如果有特殊需求，可以考虑：

**Argo Workflows**：
- 适合：已有 Kubernetes 基础设施的团队
- 优势：云原生、高性能、CNCF 毕业项目
- 劣势：需要 K8s 环境，YAML 定义为主

**Windmill**：
- 适合：开发团队技术能力强，需要高性能
- 优势：速度快，多语言支持，代码+可视化结合

**Temporal**：
- 适合：对可靠性要求极高的企业级场景
- 优势：永不丢失的任务执行，大公司验证

**Prefect**：
- 适合：Python 技术栈的数据团队
- 优势：Python 友好，易于测试，现代化 UI

### 8.3 下一步行动

1. **环境搭建**
   - [ ] 准备服务器资源
   - [ ] 部署 n8n（Docker Compose）
   - [ ] 配置域名和 HTTPS

2. **节点开发**
   - [ ] 开发阿里云 OSS 自定义节点
   - [ ] 测试节点功能
   - [ ] 编写节点使用文档

3. **前端集成**
   - [ ] 开发工作流管理页面
   - [ ] 集成 n8n 编辑器（iframe）
   - [ ] 实现工作流列表和执行日志

4. **后端 API**
   - [ ] 封装 n8n API
   - [ ] 实现权限控制
   - [ ] 日志聚合和监控

5. **测试上线**
   - [ ] 创建示例工作流
   - [ ] 用户培训
   - [ ] 监控和优化

### 8.4 技术支持

如需进一步帮助，可以：

1. **n8n 官方资源**
   - 文档：https://docs.n8n.io/
   - 社区：https://community.n8n.io/
   - GitHub：https://github.com/n8n-io/n8n

2. **阿里云 OSS SDK**
   - 文档：https://help.aliyun.com/document_detail/32027.html
   - Node.js SDK：https://github.com/ali-sdk/ali-oss

3. **本文档相关**
   - 提供完整的部署脚本
   - 提供自定义节点开发示例
   - 提供前后端集成代码

---

**文档结束**

本方案可根据实际情况调整和优化。